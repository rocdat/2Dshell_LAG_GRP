#include<stdio.h>
#include<math.h>
#include<malloc.h>
#define sec 0. //sec=0 1st order godunov,sec=0.5 godunov MUSCL
#define pi (4.*atan(1.0))
#define Md 420// vector dimension
#define Mt 25// theta dimension
#define GammaL (1.4)
#define GammaR (1.4)
//#define Gamma (1.4)  //Ratio of special heats Gamma=1.4 or 5/3
#define Ncell 410  // Number of computing cells in r direction
#define Ndis 400
#define Tcell 20 // Number of computing cells in theta direction
#define Diaph1 (10.)
#define Diaph2 (10.2)
#define Diaph 5.    // Initial discontinuity position
#define Domlen (10.25)//50.  // Domain length
#define Timeout 0.001//25. // Output time
#define CFL 0.45// CFL condition
#define m 3.// m=1 planar;m=2 cylindrical;m=3 spherical
#define Epsilon 1.5
#define DL0 (0.00129)//21.7333
#define DR0 (19.237)//2.
#define UL0 0.
#define UR0 (-2.*1e3)//0.
#define PL0 (1.01325*1e6)//15.514//(1.08*1e5)
#define PR0 (1.01325*1e6)//1.//(1e-6)
#define KK (0) //ALE number
#include"./inp.h"
int main()
{
	//parameters
	double Gamma=1.4;
    double DL=DL0,DR=DR0,UL=UL0,UR=UR0,PL=PL0,PR=PR0;//D:Density;U:Velocity;P:Pressure
	double CL,CR;CL=sqrt(Gamma*PL/DL);CR=sqrt(Gamma*PR/DR);//Sound speed
	double RR[Md],DD[Md],UU[Md],PP[Md],CC[Md];FILE *out,*outs;out=fopen("data.m","w");outs=fopen("datas.m","w");
    printf("CL=%f,CR=%f\n",CL,CR);
	double dt=1e-4,Uold,tt=0.2;int Ntime,k;Ntime=(int)(Timeout/dt);
	double F1[Md],F2[Md],F3[Md],E1[Md],E2[Md],E3[Md],Speed1[Md],Speed2[Md];
	double M[Md];//mass
		double PM,UM,Smax,time=0.;	
		double dr,r,rpos,S,D,U,P;dr=(double)Domlen/Ncell;int i;
	RR[0]=0.;RR[Ncell+1]=Domlen;//boundary node
	double DML,DMR,Ddr[Md],deltar,Uplus,Uminus;Ntime=10000;
	double dtheta;dtheta=0.5*pi/Tcell;RR[Ncell+1]=Domlen*cos(0.5*dtheta); 
	if(2./(Gamma-1.)*(CL+CR)<=(UR-UL))
	{
	printf("Error:Vacuum is generated by data!\n");
	return 0;
	}
	Ddr[0]=0.5*dr*cos(0.5*dtheta);
	double Rb[Md],Ub[Md];//cell boundary
	double mass[Md],vol[Md],Rbh[Md];
	for(i=1;i<=Ncell;i++)
	{
		RR[i]=(i-0.5)*dr*cos(0.5*dtheta);Ddr[i]=dr*cos(0.5*dtheta);//XXfor x_j
		Rb[i]=i*dr*cos(0.5*dtheta);
		//if(i==Ncell){Ddx[i]=0.5*dx;}//the length of Ncell th cell=0.5dx
		if(RR[i]<=Diaph1)
		//if(RR[i]<10*dr)
		{
			DD[i]=DL;UU[i]=UL;PP[i]=PL;//CC[i]=sqrt(Gamma*PL/DL);
		}
		else
		{
			if(RR[i]<=Diaph2)
			{
			DD[i]=DR;UU[i]=UL;PP[i]=PR;//CC[i]=sqrt(Gamma*PR/DR);
			}
			else
			{DD[i]=DR;UU[i]=UR;PP[i]=PR;}
		}
		if(i<=Ndis)
		{Gamma=GammaL;}
		else
		{Gamma=GammaR;}
		CC[i]=sqrt(Gamma*PP[i]/DD[i]);
		M[i]=Ddr[i];
		//E1[i]=1./DD[i];
		//E2[i]=UU[i];
		//E3[i]=(0.5*UU[i]*UU[i]+PP[i]/((Gamma-1.)*DD[i]));
		E1[i]=DD[i];//*pow(RR[i],m-1.);
		E2[i]=UU[i];//*pow(RR[i],m-1.);
		E3[i]=(0.5*UU[i]*UU[i]+PP[i]/(DD[i]*(Gamma-1.)));//*pow(RR[i],m-1.);
		//E3[i]=PP[i]/pow(DD[i],Gamma);//Entropy conservation
	}//initial value
	Rb[0]=0.;Rbh[0]=0.;
	for(i=1;i<=Ncell;i++)
	{
	vol[i]=RR[i]*RR[i]*(Rb[i]-Rb[i-1]);//m=3.
	mass[i]=DD[i]*vol[i];
	}
		deltar=dr*cos(0.5*dtheta);E3[0]=E3[1]*DD[1];E1[0]=E1[1];
		for(i=1;i<=Ncell;i++)
		{
			deltar=(deltar<Ddr[i]?deltar:Ddr[i]);
			if(deltar<0){printf("error\n");}
		}
		Smax=0.;
			Smax=(Smax>(fabs(UL)+CL)?Smax:(fabs(UL)+CL));
			Smax=(Smax>(fabs(UR)+CR)?Smax:(fabs(UR)+CR));
if(Smax>0.){dt=CFL*deltar/Smax;printf("Smax=%lf,deltar=%lf\n",Smax,deltar);}
		else{dt=CFL*0.1*dr;}
		printf("dt=%lf\n",dt);
		M[0]=M[1];M[Ncell+1]=M[Ncell];RR[0]=0.;RR[Ncell+1]=Domlen*cos(0.5*dtheta);Rb[0]=0.;Rb[Ncell+1]=Domlen*cos(0.5*dtheta);
		Ddr[0]=Ddr[1];Ddr[Ncell+1]=Ddr[Ncell];
    DD[0]=DD[1];UU[0]=UU[1];PP[0]=PP[1];DD[Ncell+1]=DD[Ncell];UU[Ncell+1]=UU[Ncell];PP[Ncell+1]=PP[Ncell];//boundary
	double DmD[Md],DmU[Md],DmP[Md],Dmtau[Md],slopeL,slopeR,DDL,DDR,DUL,DUR,DPL,DPR,tau_star,C_star,Dttau,DtU,DtP,DtD,TDSL,TDSR,DpsiL,DphiR,//DtauL,DtauR,
		Us,Ps,Ds;//derivative
	double //taumin[Md],
		Umin[Md],Pmin[Md],Dmin[Md],sD,stau,sU,sP,C_starL,C_starR,F2P[Md],F1P[Md],F3P[Md];
	for(i=1;i<=Ncell;i++)
	{DmD[i]=(DD[i]-DD[i-1])/M[i];DmU[i]=(UU[i]-UU[i-1])/M[i];DmP[i]=(PP[i]-PP[i-1])/M[i];Dmtau[i]=(1./DD[i]-1./DD[i-1])/M[i];}
	for(i=1;i<=Ncell;i++)
	{DmD[i]=0.;DmU[i]=0.;DmP[i]=0.;Dmtau[i]=0.;}
	DmD[0]=DmD[1];DmU[0]=DmU[1];DmP[0]=DmP[1];DmD[Ncell+1]=DmD[Ncell];DmU[Ncell+1]=DmU[Ncell];DmP[Ncell+1]=DmP[Ncell];
	Dmtau[0]=Dmtau[1];Dmtau[Ncell+1]=Dmtau[Ncell];
	dt=1e-4;
	 DD[0]=DD[1];UU[0]=UU[1];PP[0]=PP[1];DD[Ncell+1]=DD[Ncell];UU[Ncell+1]=UU[Ncell];PP[Ncell+1]=PP[Ncell];
	 //double f1,f3,fE;fE=E3[0]/(pow(RR[1],m-1.));
//	for(k=1;k<=100;k++)
	 for(k=1;k<=1000000;k++)
	{
		
	for(i=1;i<=Ncell;i++)
		{
			if(i<=Ndis)
		{Gamma=GammaL;}
		else
		{Gamma=GammaR;}
			slopeL=DmD[i];slopeR=DmD[i+1];
			//DL=DD[i]+0.5*M[i]*slopeL;DR=DD[i+1]-0.5*M[i+1]*slopeR;
			DL=DD[i]+0.5*Ddr[i]*slopeL;DR=DD[i+1]-0.5*Ddr[i+1]*slopeR;
			slopeL=DmU[i];slopeR=DmU[i+1];
			//UL=UU[i]+0.5*M[i]*slopeL;UR=UU[i+1]-0.5*M[i+1]*slopeR;
			UL=UU[i]+0.5*Ddr[i]*slopeL;UR=UU[i+1]-0.5*Ddr[i+1]*slopeR;
			slopeL=DmP[i];slopeR=DmP[i+1];
			//PL=PP[i]+0.5*M[i]*slopeL;PR=PP[i+1]-0.5*M[i+1]*slopeR;
			PL=PP[i]+0.5*Ddr[i]*slopeL;PR=PP[i+1]-0.5*Ddr[i+1]*slopeR;
			CL=sqrt(Gamma*PL/DL);CR=sqrt(Gamma*PR/DR);
			DUL=DmU[i];DUR=DmU[i+1];DPL=DmP[i];DPR=DmP[i+1];//DtauL=Dmtau[i];DtauR=Dmtau[i+1];
			DDL=DmD[i];DDR=DmD[i+1];
StarPU(PM,UM,DL,DR,UL,UR,PL,PR,CL,CR,Gamma);
if(PM>PL)//left shock
{
	Speed1[i]=UL-CL*sqrt(PM/PL*(Gamma+1)/(2.*Gamma)+(Gamma-1.)/(2.*Gamma));//Euler
	//Speed1[i]=-CL*DL*sqrt(PM/PL*(Gamma+1)/(2.*Gamma)+(Gamma-1.)/(2.*Gamma));//L
	DML=1./(1./DL-(UM-UL)/Speed1[i]);
}
else//left fan
{
	Speed1[i]=UL-CL;
	//Speed1[i]=-CL*DL;
	DML=DL*pow(PM/PL,1./Gamma);
}
if(PM>PR)//right shock
{
	Speed2[i]=UR+CR*sqrt(PM/PR*(Gamma+1)/(2.*Gamma)+(Gamma-1.)/(2.*Gamma));
	//Speed2[i+1]=CR*DR*sqrt(PM/PR*(Gamma+1)/(2.*Gamma)+(Gamma-1.)/(2.*Gamma));
	DMR=1./(1./DR-(UM-UR)/Speed2[i+1]);
}
else//right fan
{
	Speed2[i]=UR+CR;
	//Speed2[i+1]=CR*DR;
	DMR=DR*pow(PM/PR,1./Gamma);
}
	}//end for 1 round
	for(i=1;i<Ncell;i++)
		{
			Smax=(Smax>fabs(Speed1[i])?Smax:fabs(Speed1[i]));
		}
		for(i=1;i<Ncell;i++)
		{
			Smax=(Smax>fabs(Speed2[i])?Smax:fabs(Speed2[i]));
		}
		for(i=1;i<=Ncell;i++)
		{
			deltar=(deltar<Ddr[i]?deltar:Ddr[i]);
			if(deltar<0){printf("error\n");}
		}
	
		if(Smax>0.){dt=CFL*deltar/Smax;//printf("Smax=%lf,deltar=%lf\n",Smax,deltar);
		}
		else{dt=CFL*0.1*dr;}
		if(time<Timeout&&(time+dt)>Timeout)
		{dt=Timeout-time;}//compute for time step
	
		for(i=1;i<=Ncell;i++)
		{
				if(i<=Ndis)
		{Gamma=GammaL;}
		else
		{Gamma=GammaR;}
			slopeL=DmD[i];slopeR=DmD[i+1];
			//DL=DD[i]+0.5*M[i]*slopeL;DR=DD[i+1]-0.5*M[i+1]*slopeR;
			DL=DD[i]+0.5*Ddr[i]*slopeL;DR=DD[i+1]-0.5*Ddr[i+1]*slopeR;
			slopeL=DmU[i];slopeR=DmU[i+1];
			//UL=UU[i]+0.5*M[i]*slopeL;UR=UU[i+1]-0.5*M[i+1]*slopeR;
			UL=UU[i]+0.5*Ddr[i]*slopeL;UR=UU[i+1]-0.5*Ddr[i+1]*slopeR;
			slopeL=DmP[i];slopeR=DmP[i+1];
			//PL=PP[i]+0.5*M[i]*slopeL;PR=PP[i+1]-0.5*M[i+1]*slopeR;
			PL=PP[i]+0.5*Ddr[i]*slopeL;PR=PP[i+1]-0.5*Ddr[i+1]*slopeR;
			CL=sqrt(Gamma*PL/DL);CR=sqrt(Gamma*PR/DR);
			DUL=DmU[i];DUR=DmU[i+1];DPL=DmP[i];DPR=DmP[i+1];//DtauL=Dmtau[i];DtauR=Dmtau[i+1];
			DDL=DmD[i];DDR=DmD[i+1];
StarPU(PM,UM,DL,DR,UL,UR,PL,PR,CL,CR,Gamma);
if(PM>PL)//left shock
{
	Speed1[i]=UL-CL*sqrt(PM/PL*(Gamma+1)/(2.*Gamma)+(Gamma-1.)/(2.*Gamma));//Euler
	//Speed1[i]=-CL*DL*sqrt(PM/PL*(Gamma+1)/(2.*Gamma)+(Gamma-1.)/(2.*Gamma));//L
	DML=1./(1./DL-(UM-UL)/Speed1[i]);
}
else//left fan
{
	Speed1[i]=UL-CL;
	//Speed1[i]=-CL*DL;
	DML=DL*pow(PM/PL,1./Gamma);
}
if(PM>PR)//right shock
{
	Speed2[i]=UR+CR*sqrt(PM/PR*(Gamma+1)/(2.*Gamma)+(Gamma-1.)/(2.*Gamma));
	//Speed2[i+1]=CR*DR*sqrt(PM/PR*(Gamma+1)/(2.*Gamma)+(Gamma-1.)/(2.*Gamma));
	DMR=1./(1./DR-(UM-UR)/Speed2[i+1]);
}
else//right fan
{
	Speed2[i]=UR+CR;
	//Speed2[i+1]=CR*DR;
	DMR=DR*pow(PM/PR,1./Gamma);
}
//S=0.;//SampleL(D,U,P,PM,UM,S,DL,DR,UL,UR,PL,PR,CL,CR,DML,DMR);
//if(i<=2)
if(i<=KK)
{S=0.;}
else{S=UM;}
r=Rb[i];//0.5*(Rb[i]+Rb[i+1]); 
Sample(D,U,P,PM,UM,S,DL,DR,UL,UR,PL,PR,CL,CR,Gamma);
if((DL-DR)*(DL-DR)+(UL-UR)*(UL-UR)+(PL-PR)*(PL-PR)<1e-6)//Acoustic case
{
tau_star=1./D;C_star=sqrt(Gamma*P/D);
//Acoustic(Dttau,DtU,DtP,DUL,DUR,DPL,DPR,tau_star,C_star);
//AcousticE(DtD,DtU,DtP,DDL,DDR,DUL,DUR,DPL,DPR,D,U,C_star,S);
AcousticS(DtD,DtU,DtP,DDL,DDR,DUL,DUR,DPL,DPR,D,U,C_star,S,r);
//printf("Acoustic case:DtD=%lf,DtU=%lf,DtP=%lf\n",DtD,DtU,DtP);
}
else// non Acoustic case
{
TDSL=-CL*CL/(DL*(Gamma-1.))*DDL+1./(DL*(Gamma-1.))*DPL;
TDSR=-CR*CR/(DR*(Gamma-1.))*DDR+1./(DR*(Gamma-1.))*DPR;
DpsiL=DUL+Gamma/((Gamma-1.)*CL*DL)*DPL-CL/(DL*(Gamma-1.))*DDL;
DphiR=DUR-Gamma/((Gamma-1.)*CR*DR)*DPR+CR/(DR*(Gamma-1.))*DDR;
C_starL=CL*pow(PM/PL,(Gamma-1.)/(2.*Gamma));C_starR=CR*pow(PM/PR,(Gamma-1.)/(2.*Gamma));
//GRPsolver(Dttau,DtU,DtP,UM,PM,DL,DR,UL,UR,PL,PR,DtauL,DtauR,DUL,DUR,DPL,DPR,TDSL,TDSR,DpsiL,DphiR);
if(S>=(UM-C_starL)&&S<=(UM+C_starR))
{//nonsonic case
//GRPsolverE(DtD,DtU,DtP,UM,PM,DL,DR,UL,UR,PL,PR,DDL,DDR,DUL,DUR,DPL,DPR,TDSL,TDSR,DpsiL,DphiR,S);
GRPsolverES(DtD,DtU,DtP,UM,PM,DL,DR,UL,UR,PL,PR,DDL,DDR,DUL,DUR,DPL,DPR,TDSL,TDSR,DpsiL,DphiR,S,r,Gamma);
//printf("Nonsonic case\n");
}
else
{//sonic case
//GRPsolverS(DtD,DtU,DtP,UM,PM,DL,DR,UL,UR,PL,PR,DDR,DUR,DPR,TDSL,TDSR,DpsiL,DphiR,S);
GRPsolverSS(DtD,DtU,DtP,UM,PM,DL,DR,UL,UR,PL,PR,DDR,DUR,DPR,TDSL,TDSR,DpsiL,DphiR,S,r,Gamma);
//printf("Sonic case!PL=%lf,UM=%lf,PM=%lf,PR=%lf\n",PL,UM,PM,PR);
}
if(S<=(UL-CL)||S>=(UR+CR))
{
GRPsolverSS1(DtD,DtU,DtP,DL,DR,UL,UR,PL,PR,DDL,DDR,DUL,DUR,DPL,DPR,S,r,Gamma);
}
//printf("Non Acoustic case:DtD=%lf,DtU=%lf,DtP=%lf,TDSL=%lf,TDSR=%lf,DpsiL=%lf,DphiR=%lf\n",DtD,DtU,DtP,
//	   TDSL,TDSR,DpsiL,DphiR);
}
Ub[i]=S+0.5*dt*DtU;
//if(i<=2)
if(i<=KK)
{Ub[i]=0.;}

		}//end for 2 round
		Rb[Ncell+1]=Rb[Ncell];
	for(i=1;i<=Ncell;i++)
		{
			if(i<=Ndis)
		{Gamma=GammaL;}
		else
		{Gamma=GammaR;}
			slopeL=DmD[i];slopeR=DmD[i+1];
			//DL=DD[i]+0.5*M[i]*slopeL;DR=DD[i+1]-0.5*M[i+1]*slopeR;
			DL=DD[i]+0.5*Ddr[i]*slopeL;DR=DD[i+1]-0.5*Ddr[i+1]*slopeR;
			slopeL=DmU[i];slopeR=DmU[i+1];
			//UL=UU[i]+0.5*M[i]*slopeL;UR=UU[i+1]-0.5*M[i+1]*slopeR;
			UL=UU[i]+0.5*Ddr[i]*slopeL;UR=UU[i+1]-0.5*Ddr[i+1]*slopeR;
			slopeL=DmP[i];slopeR=DmP[i+1];
			//PL=PP[i]+0.5*M[i]*slopeL;PR=PP[i+1]-0.5*M[i+1]*slopeR;
			PL=PP[i]+0.5*Ddr[i]*slopeL;PR=PP[i+1]-0.5*Ddr[i+1]*slopeR;
			CL=sqrt(Gamma*PL/DL);CR=sqrt(Gamma*PR/DR);
			DUL=DmU[i];DUR=DmU[i+1];DPL=DmP[i];DPR=DmP[i+1];//DtauL=Dmtau[i];DtauR=Dmtau[i+1];
			DDL=DmD[i];DDR=DmD[i+1];
StarPU(PM,UM,DL,DR,UL,UR,PL,PR,CL,CR,Gamma);
if(PM>PL)//left shock
{
	Speed1[i]=UL-CL*sqrt(PM/PL*(Gamma+1)/(2.*Gamma)+(Gamma-1.)/(2.*Gamma));//Euler
	//Speed1[i]=-CL*DL*sqrt(PM/PL*(Gamma+1)/(2.*Gamma)+(Gamma-1.)/(2.*Gamma));//L
	DML=1./(1./DL-(UM-UL)/Speed1[i]);
}
else//left fan
{
	Speed1[i]=UL-CL;
	//Speed1[i]=-CL*DL;
	DML=DL*pow(PM/PL,1./Gamma);
}
if(PM>PR)//right shock
{
	Speed2[i+1]=UR+CR*sqrt(PM/PR*(Gamma+1)/(2.*Gamma)+(Gamma-1.)/(2.*Gamma));
	//Speed2[i+1]=CR*DR*sqrt(PM/PR*(Gamma+1)/(2.*Gamma)+(Gamma-1.)/(2.*Gamma));
	DMR=1./(1./DR-(UM-UR)/Speed2[i+1]);
}
else//right fan
{
	Speed2[i+1]=UR+CR;
	//Speed2[i+1]=CR*DR;
	DMR=DR*pow(PM/PR,1./Gamma);
}
//S=0.;//SampleL(D,U,P,PM,UM,S,DL,DR,UL,UR,PL,PR,CL,CR,DML,DMR);
//if(i<=2)
if(i<=KK)
{S=0.;}
else{S=Ub[i];}
r=Rb[i];//0.5*(Rb[i]+Rb[i+1]); 
Sample(D,U,P,PM,UM,S,DL,DR,UL,UR,PL,PR,CL,CR,Gamma);
if((DL-DR)*(DL-DR)+(UL-UR)*(UL-UR)+(PL-PR)*(PL-PR)<1e-6)//Acoustic case
{
tau_star=1./D;C_star=sqrt(Gamma*P/D);
//Acoustic(Dttau,DtU,DtP,DUL,DUR,DPL,DPR,tau_star,C_star);
//AcousticE(DtD,DtU,DtP,DDL,DDR,DUL,DUR,DPL,DPR,D,U,C_star,S);
AcousticS(DtD,DtU,DtP,DDL,DDR,DUL,DUR,DPL,DPR,D,U,C_star,S,r);
//printf("Acoustic case:Dttau=%lf,DtU=%lf,DtP=%lf\n",Dttau,DtU,DtP);
}
else// non Acoustic case
{
//TDSL=CL*CL*DL/(Gamma-1.)*DtauL+1./(DL*(Gamma-1.))*DPL;
//TDSR=CR*CR*DR/(Gamma-1.)*DtauR+1./(DR*(Gamma-1.))*DPR;
//DpsiL=DUL+Gamma/((Gamma-1.)*CL*DL)*DPL+CL*DL/(Gamma-1.)*DtauL;
//DphiR=DUR-Gamma/((Gamma-1.)*CR*DR)*DPR-CR*DR/(Gamma-1.)*DtauR;
TDSL=-CL*CL/(DL*(Gamma-1.))*DDL+1./(DL*(Gamma-1.))*DPL;
TDSR=-CR*CR/(DR*(Gamma-1.))*DDR+1./(DR*(Gamma-1.))*DPR;
DpsiL=DUL+Gamma/((Gamma-1.)*CL*DL)*DPL-CL/(DL*(Gamma-1.))*DDL;
DphiR=DUR-Gamma/((Gamma-1.)*CR*DR)*DPR+CR/(DR*(Gamma-1.))*DDR;
C_starL=CL*pow(PM/PL,(Gamma-1.)/(2.*Gamma));C_starR=CR*pow(PM/PR,(Gamma-1.)/(2.*Gamma));
//GRPsolver(Dttau,DtU,DtP,UM,PM,DL,DR,UL,UR,PL,PR,DtauL,DtauR,DUL,DUR,DPL,DPR,TDSL,TDSR,DpsiL,DphiR);
if(S>=(UM-C_starL)&&S<=(UM+C_starR))
{//nonsonic case
//GRPsolverE(DtD,DtU,DtP,UM,PM,DL,DR,UL,UR,PL,PR,DDL,DDR,DUL,DUR,DPL,DPR,TDSL,TDSR,DpsiL,DphiR,S);
GRPsolverES(DtD,DtU,DtP,UM,PM,DL,DR,UL,UR,PL,PR,DDL,DDR,DUL,DUR,DPL,DPR,TDSL,TDSR,DpsiL,DphiR,S,r,Gamma);
//printf("Nonsonic case\n");
}
else
{//sonic case
//GRPsolverS(DtD,DtU,DtP,UM,PM,DL,DR,UL,UR,PL,PR,DDR,DUR,DPR,TDSL,TDSR,DpsiL,DphiR,S);
GRPsolverSS(DtD,DtU,DtP,UM,PM,DL,DR,UL,UR,PL,PR,DDR,DUR,DPR,TDSL,TDSR,DpsiL,DphiR,S,r,Gamma);
//printf("Sonic case\n");
}
if(S<=(UL-CL)||S>=(UR+CR))
{
GRPsolverSS1(DtD,DtU,DtP,DL,DR,UL,UR,PL,PR,DDL,DDR,DUL,DUR,DPL,DPR,S,r,Gamma);
}
//printf("Non Acoustic case:DtD=%lf,DtU=%lf,DtP=%lf,TDSL=%lf,TDSR=%lf,DpsiL=%lf,DphiR=%lf\n",DtD,DtU,DtP,
//	   TDSL,TDSR,DpsiL,DphiR);
}
Rbh[i]=Rb[i]+Ub[i]*dt*0.5;
Rb[i]=Rb[i]+Ub[i]*dt;
Us=U+0.5*dt*DtU;Ps=P+0.5*dt*DtP;//taus=1./D+0.5*dt*Dttau;DtD=-D*D*Dttau;
Ds=D+0.5*dt*DtD;
//if(i==1){p1=Ps;}
//if(i==2){p2=Ps;}
//Ph[i]=Ps;
F1[i]=Ds;
F2[i]=Ps;
F3[i]=Ps*Us;
//F1[i]=Ds*(Us-S);F2[i]=Ds*Us*(Us-S)+Ps;F3[i]=Ds*(0.5*Us*Us+Ps/(Ds*(Gamma-1.)))*(Us-S)+Us*Ps;
//F1[i]=F1[i]*pow(Rb[i],m-1.);F2[i]=F2[i]*pow(Rb[i],m-1.);F3[i]=F3[i]*pow(Rb[i],m-1.);
if(m==1.){F2P[i]=0.;F1P[i]=0.;F3P[i]=0.;}
else
{
	F2P[i]=-(m-1.)/Rb[i]*Ds*Us*Us;F1P[i]=-(m-1.)/Rb[i]*Ds*Us;F3P[i]=-(m-1.)/Rb[i]*Us*(Ps+Ds*(0.5*Us*Us+Ps/(Ds*(Gamma-1.))));}
//taumin[i]=1./D+dt*Dttau;
Umin[i]=U+dt*DtU;Pmin[i]=P+dt*DtP;Dmin[i]=D+dt*DtD;
//F3[i]=0.;//Entropy conservation
//if(i==0){f1=Ds*Us;f3=Ds*(0.5*Us*Us+Ps/(Ds*(Gamma-1.)))*Us+Us*Ps;}
		}//end for 3 round
		DD[0]=DD[0]-dt*2.*F1[1]*F3[1]/F2[1]/dr;
E3[0]=E3[0]-dt*2.*(F3[1]/dr+F3[1]/F2[1]*F1[1]*(0.5*F3[1]/F2[1]*F3[1]/F2[1]+F2[1]/((Gamma-1)*F1[1]))/dr);
UU[0]=E3[0]*(Gamma-1);
F2[0]=F2[1]-DmP[1]*(Rbh[1]-0.);//0.5*(UU[0]+PP[0]);//F2[1];//interp1(Rbh[0],Rbh[1],F2[1],Rbh[2],F2[2]);
//F2[0]=F2[1]-(F2[2]-F2[1])/(Rbh[2]-Rbh[1])*Rbh[1];
F3[0]=0.;
PP[0]=UU[0];
UU[0]=0.;		
		//for(i=0;i<=Ncell;i++){Xb[i]=Xb[i]+dt*Ub[i];}
//time step
		//for(i=0;i<=Ncell;i++){printf("Xb[%d]=%lf\n",i,Xb[i]);}
		for(i=1;i<=Ncell;i++){
			vol[i]=(Rb[i]-Rb[i-1])*0.5*(Rb[i]+Rb[i-1])*0.5*(Rb[i]+Rb[i-1]);
			DD[i]=mass[i]/vol[i];
			M[i]=Rb[i]-Rb[i-1];
		Ddr[i]=M[i];}		
M[0]=M[1];M[Ncell+1]=M[Ncell];
Ddr[0]=Ddr[1];Ddr[Ncell+1]=Ddr[Ncell];Rb[0]=0.;Rbh[0]=0.;
		for(i=1;i<Ncell;i++)//m=3
		{
		//E1[i]=(E1[i]*Ddr[i]-dt*(F1[i]-F1[i-1]))/M[i]+0.5*dt*(F1P[i]+F1P[i-1])*0.5*(M[i]+Ddr[i])/M[i];
		//E2[i]=(E2[i]*Ddr[i]-dt*(F2[i]-F2[i-1])+0.5*dt*(F2P[i]+F2P[i-1])*0.5*(M[i]+Ddr[i]))/M[i];
		//E3[i]=(E3[i]*Ddr[i]-dt*(F3[i]-F3[i-1]))/M[i]+0.5*dt*(F3P[i]+F3P[i-1])*0.5*(M[i]+Ddr[i])/M[i];
		E2[i]=E2[i]-dt/mass[i]*(F2[i]*Rbh[i]*Rbh[i]-F2[i-1]*Rbh[i-1]*Rbh[i-1])+0.5*dt*(Rbh[i]-Rbh[i-1])*2.*0.5
			*(Rbh[i]+Rbh[i-1])*(F2[i]+F2[i-1])/mass[i];
		if(i==1){
	//E2[i]=E2[i]-dt/mass[i]*(F2[i]*Rbh[i]*Rbh[i]-F2[i-1]*Rbh[i-1]*Rbh[i-1])+dt*(Rbh[i]-Rbh[i-1])*PP[i]/mass[i];
		}
		E3[i]=E3[i]-dt/mass[i]*(F3[i]*Rbh[i]*Rbh[i]-F3[i-1]*Rbh[i-1]*Rbh[i-1]);

		}
		E2[1]=0.;
		//Decoding to get physical variables
		for(i=1;i<Ncell;i++)
		{
				if(i<=Ndis)
		{Gamma=GammaL;}
		else
		{Gamma=GammaR;}
			RR[i]=0.5*(Rb[i]+Rb[i-1]);
			//Uold=UU[i];
			//DD[i]=E1[i];///pow(RR[i],m-1.);
			UU[i]=E2[i];
			PP[i]=(E3[i]-0.5*UU[i]*UU[i])*(Gamma-1.)*DD[i];
			//PP[i]=E3[i]*pow(DD[i],Gamma);//Entropy conservation
			//XX[i]=XX[i]+0.5*dt*(UU[i]+Uold);
			
		}
	//	UU[1]=UU[2];PP[1]=PP[2];
//		RR[1]=0.5*(Rb[1]+Rb[0]);
//DD[0]=DD[1];UU[0]=UU[1];PP[0]=PP[1];
//		E1[1]=(E1[1]*Ddr[1]-m*dt*F1[1])/M[1];
//		DD[1]=E1[1];
	//E1[0]=(E1[0]*Ddr[0]-m*dt*F1[0])/M[0];
//	DD[0]=DD[0]-m*dt*f1/dr;
	//	DD[0]=E1[0]/(pow(RR[1],m-1.));
		UU[1]=0.;
	UU[0]=0.;
  //  E3[1]=(E3[1]*Ddr[1]-m*dt*F3[1])/M[1];
	//PP[1]=(E3[1]/E1[1]-0.5*UU[1]*UU[1])*(Gamma-1.)*DD[1];
//	PP[0]=PP[1];
DD[Ncell]=DD[Ncell-1];UU[Ncell]=UU[Ncell-1];PP[Ncell]=PP[Ncell-1];	
DD[Ncell+1]=DD[Ncell];UU[Ncell+1]=UU[Ncell];PP[Ncell+1]=PP[Ncell];
for(i=2;i<Ncell;i++)
{
//stau=(taumin[i]-taumin[i-1])/M[i];
sU=(Umin[i]-Umin[i-1])/M[i];sP=(Pmin[i]-Pmin[i-1])/M[i];sD=(Dmin[i]-Dmin[i-1])/M[i];
DmD[i]=minmod(Epsilon*(DD[i]-DD[i-1])/(RR[i]-RR[i-1]),sD,Epsilon*(DD[i+1]-DD[i])/(RR[i+1]-RR[i]));
DmU[i]=minmod(Epsilon*(UU[i]-UU[i-1])/(RR[i]-RR[i-1]),sU,Epsilon*(UU[i+1]-UU[i])/(RR[i+1]-RR[i]));
DmP[i]=minmod(Epsilon*(PP[i]-PP[i-1])/(RR[i]-RR[i-1]),sP,Epsilon*(PP[i+1]-PP[i])/(RR[i+1]-RR[i]));
//printf("a=%lf,b=%lf,c=%lf\n",Epsilon*(1./DD[i]-1./DD[i-1])/M[i],stau,Epsilon*(1./DD[i+1]-1./DD[i])/M[i+1]);
//Dmtau[i]=minmod(Epsilon*(1./DD[i]-1./DD[i-1])/M[i],stau,Epsilon*(1./DD[i+1]-1./DD[i])/M[i+1]);
//printf("a=%lf,b=%lf,c=%lf\n",Epsilon*(UU[i]-UU[i-1])/M[i],sU,Epsilon*(UU[i+1]-UU[i])/M[i+1]);
//printf("a=%lf,b=%lf,c=%lf\n",Epsilon*(PP[i]-PP[i-1])/M[i],sP,Epsilon*(PP[i+1]-PP[i])/M[i+1]);
//printf("a=%lf,b=%lf,c=%lff\n",Epsilon*(DD[i]-DD[i-1])/M[i],sD,Epsilon*(DD[i+1]-DD[i])/M[i+1]);

//printf("DmU[%d]=%lf,DmP[%d]=%lf,DmD[%d]=%lf\n",i,DmU[i],i,DmP[i],i,DmD[i]);
}
DmD[1]=minmod2((Dmin[1]-DD[1])/(0.5*M[1]),DmD[2]);
DmU[1]=minmod2((Umin[1]-UU[1])/(0.5*M[1]),DmU[2]);
DmP[1]=minmod2((Pmin[1]-PP[1])/(0.5*M[1]),DmP[2]);
//DmD[Ncell+1]=minmod2((Dmin[Ncell]-DD[Ncell])/(0.5*M[Ncell]),DmD[Ncell-1]);
//Dmtau[0]=Dmtau[1];
//DmU[0]=DmU[1];DmP[0]=DmP[1];DmD[0]=DmD[1];
//Dmtau[Ncell+1]=Dmtau[Ncell];
DmU[Ncell]=DmU[Ncell-1];DmP[Ncell]=DmP[Ncell-1];DmD[Ncell]=DmD[Ncell-1];
DmU[Ncell+1]=DmU[Ncell];DmP[Ncell+1]=DmP[Ncell];DmD[Ncell+1]=DmD[Ncell];
for(i=1;i<=Ncell;i++)
{
//DmD[i]=0.;DmU[i]=0.;DmP[i]=0.;
//	Ddr[i]=M[i]; 
}
//Ddr[0]=Ddr[1];Ddr[Ncell+1]=Ddr[Ncell];
		time=time+dt;
		for(i=0;i<=(Ncell+1);i++){Ddr[i]=M[i];}
		printf("Time[%d]=%e,dt=%e\n",k,time,dt);
		if(fabs(time-Timeout)<1e-6){break;}
	}//end k
	 DD[0]=DD[1];//UU[0]=UU[1];
	 PP[0]=PP[1];
	 DD[Ncell+1]=DD[Ncell];UU[Ncell+1]=UU[Ncell];PP[Ncell+1]=PP[Ncell];
	 RR[0]=0.;RR[Ncell+1]=Domlen*cos(0.5*dtheta);
fprintf(outs,"RR=[");Write(outs,RR,Ncell+1);
	//for(i=1;i<=Ncell;i++)
	//{
	//	XX[i]=i*dx;
	//}
//fprintf(outs,"XX=[");Write(outs,XX,Ncell);
fprintf(outs,"DD=[");Write(outs,DD,Ncell+1);
	fprintf(outs,"UU=[");Write(outs,UU,Ncell+1);fprintf(outs,"PP=[");Write(outs,PP,Ncell+1);	
 DL=DL0;DR=DR0;UL=UL0;UR=UR0;PL=PL0;PR=PR0;//D:Density;U:Velocity;P:Pressure
CL=sqrt(Gamma*PL/DL);CR=sqrt(Gamma*PR/DR);//Sound speed
printf("OK!\n");
	StarPU(PM,UM,DL,DR,UL,UR,PL,PR,CL,CR,Gamma);//exact solution for pressure and velocity in star region is found
	printf("P=%lf,U=%lf\n",PM,UM);
int j;double rb[Md][Mt],zb[Md][Mt],DD2[Md][Mt],UUxi2[Md][Mt],PP2[Md][Mt];
for(i=0;i<=Ncell;i++)
for(j=0;j<=Tcell;j++)
{
rb[i][j]=Rb[i]/cos(0.5*dtheta)*sin(j*dtheta);
zb[i][j]=Rb[i]/cos(0.5*dtheta)*cos(j*dtheta);
}

for(i=1;i<Ncell;i++)
for(j=1;j<Tcell;j++)
{
DD2[i][j]=0.5*(DD[i]+DD[i+1]);
UUxi2[i][j]=0.5*(UU[i]+UU[i+1]);
PP2[i][j]=0.5*(PP[i]+PP[i+1]);
}
for(i=1;i<Ncell;i++)
{
DD2[i][0]=DD2[i][1];UUxi2[i][0]=UUxi2[i][1];PP2[i][0]=PP2[i][1];
DD2[i][Tcell]=DD2[i][Tcell-1];UUxi2[i][Tcell]=UUxi2[i][Tcell-1];PP2[i][Tcell]=PP2[i][Tcell-1];
}
for(j=0;j<=Tcell;j++)
{
DD2[0][j]=DD[0];UUxi2[0][j]=UU[0];PP2[0][j]=PP[0];
DD2[Ncell][j]=DD2[Ncell-1][j];UUxi2[Ncell][j]=UUxi2[Ncell-1][j];PP2[Ncell][j]=PP2[Ncell-1][j];
}
	out=fopen("datad2d.dat","w");wrin2s(out,rb,zb,DD2);
	out=fopen("datap2d.dat","w");wrin2s(out,rb,zb,PP2);
	out=fopen("datau2d.dat","w");wrin2s(out,rb,zb,UUxi2);
	//for(i=1;i<=Ncell;i++)
	//{
	//	xpos=(i-0.5)*dx;
	//	S=(xpos-Diaph)/Timeout;
		// Solution at point (X,T)=(xpos-Diaph,Timeout) is found
      //  Sample(D,U,P,PM,UM,S,DL,DR,UL,UR,PL,PR,CL,CR);
		//printf("x[%d]=%lf,S=%lf,DS=%lf,US=%lf,PS=%lf,ES=%lf\n",i,xpos,S,D,U,P,P/(D*(Gamma-1.)));
		//XX[i]=xpos;//+0.5*dx;
		//DD[i]=D;UU[i]=U;PP[i]=P;
	//}
	//XX[0]=0.;XX[Ncell+1]=Domlen;
	//DD[0]=DD[1];UU[0]=UU[1];PP[0]=PP[1];DD[Ncell+1]=DD[Ncell];UU[Ncell+1]=UU[Ncell];PP[Ncell+1]=PP[Ncell];
	//fprintf(out,"X=[");Write(out,XX,Ncell+1);fprintf(out,"D=[");Write(out,DD,Ncell+1);
	//fprintf(out,"U=[");Write(out,UU,Ncell+1);fprintf(out,"P=[");Write(out,PP,Ncell+1);
	//printf("time=%lf,k=%d,dx=%f,deltax=%lf\n",time,k,dx,deltax);
	return 1;
}
